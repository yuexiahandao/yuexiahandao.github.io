
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Node.js核心模块 | Gavin&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Gavin Zhang">
    
    <meta name="description" content="全局对象
JavaScript 中有一个特殊的对象,称为全局对象(Global Object),它及其所有属性都可以在程序的任何地方访问,即全局变量。在浏览器 JavaScript 中,通常 window 是全局对象,而 Node.js 中的全局对象是 global ,所有全局变量(除了 globa">
    
    
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="yuexiahandao" />
    <meta name="twitter:title" content="Node.js核心模块 | Gavin&#39;s Blog" />
      
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png##img/logo.svg" alt="Gavin&#39;s Blog" title="Gavin&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Gavin&#39;s Blog">Gavin&#39;s Blog</a></h1>
				<h2 class="blog-motto">Welcome to Gavin Zhang&#39;s personal blog!</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/tags">Tags</a></li>
					
						<li><a href="/categories">Categories</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/11/Node-js核心模块/" title="Node.js核心模块" itemprop="url">Node.js核心模块</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yuexiahandao.github.com" title="Gavin Zhang">Gavin Zhang</a>
    </p>
  <p class="article-time">
    <time datetime="2014-10-11T00:33:19.000Z" itemprop="datePublished">Oct 11 2014</time>
    Updated:<time datetime="2014-10-11T15:51:14.000Z" itemprop="dateModified">Oct 11 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#全局对象"><span class="toc-number">1.</span> <span class="toc-text">全局对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局对象与全局变量"><span class="toc-number">1.1.</span> <span class="toc-text">全局对象与全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#process"><span class="toc-number">1.2.</span> <span class="toc-text">process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#console"><span class="toc-number">1.3.</span> <span class="toc-text">console</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用工具_util"><span class="toc-number">2.</span> <span class="toc-text">常用工具 util</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#util-inherits"><span class="toc-number">2.1.</span> <span class="toc-text">util.inherits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#util-inspect"><span class="toc-number">2.2.</span> <span class="toc-text">util.inspect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件驱动_events"><span class="toc-number">3.</span> <span class="toc-text">事件驱动 events</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件发射器"><span class="toc-number">3.1.</span> <span class="toc-text">事件发射器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error_事件"><span class="toc-number">3.2.</span> <span class="toc-text">error 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承_EventEmitter"><span class="toc-number">3.3.</span> <span class="toc-text">继承 EventEmitter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统_fs"><span class="toc-number">4.</span> <span class="toc-text">文件系统 fs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fs-readFile"><span class="toc-number">4.1.</span> <span class="toc-text">fs.readFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs-readFileSync"><span class="toc-number">4.2.</span> <span class="toc-text">fs.readFileSync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs-open"><span class="toc-number">4.3.</span> <span class="toc-text">fs.open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs-read"><span class="toc-number">4.4.</span> <span class="toc-text">fs.read</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP_服务器与客户端"><span class="toc-number">5.</span> <span class="toc-text">HTTP 服务器与客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP_服务器"><span class="toc-number">5.1.</span> <span class="toc-text">HTTP 服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http-Server_的事件"><span class="toc-number">5.1.1.</span> <span class="toc-text">http.Server 的事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http-ServerRequest"><span class="toc-number">5.1.2.</span> <span class="toc-text">http.ServerRequest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取_GET_请求内容"><span class="toc-number">5.1.3.</span> <span class="toc-text">获取 GET 请求内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取_POST_请求内容"><span class="toc-number">5.1.4.</span> <span class="toc-text">获取 POST 请求内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http-ServerResponse"><span class="toc-number">5.1.5.</span> <span class="toc-text">http.ServerResponse</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP_客户端"><span class="toc-number">5.2.</span> <span class="toc-text">HTTP 客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http-ClientRequest"><span class="toc-number">5.2.1.</span> <span class="toc-text">http.ClientRequest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http-ClientResponse"><span class="toc-number">5.2.2.</span> <span class="toc-text">http.ClientResponse</span></a></li></ol></li></ol></li></ol>
		</div>
		
		<h2 id="全局对象">全局对象</h2>
<p>JavaScript 中有一个特殊的对象,称为全局对象(Global Object),它及其所有属性都可以在程序的任何地方访问,即全局变量。在浏览器 JavaScript 中,通常 window 是全局对象,而 Node.js 中的全局对象是 global ,所有全局变量(除了 global 本身以外)都是 global对象的属性。<br>我们在 Node.js 中能够直接访问到对象通常都是 global 的属性,如 console 、 process等,下面逐一介绍。</p>
<h3 id="全局对象与全局变量">全局对象与全局变量</h3>
<p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义,满足以下条件的变量是全局变量:</p>
<ul>
<li>在最外层定义的变量;</li>
<li>全局对象的属性;</li>
<li>隐式定义的变量(未定义直接赋值的变量)。</li>
</ul>
<p>当你定义一个全局变量时,这个变量同时也会成为全局对象的属性,反之亦然。需要注意的是,在 Node.js 中你不可能在最外层定义变量,因为所有用户代码都是属于当前模块的,而模块本身不是最外层上下文。<br>永远使用 var 定义变量以避免引入全局变量,因为全局变量会污染命名空间,提高代码的耦合风险。</p>
<h3 id="process">process</h3>
<p>process 是一个全局变量,即 global 对象的属性。它用于描述当前 Node.js 进程状态的对象,提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候,少不了要和它打交道。下面将会介绍process 对象的一些最常用的成员方法。</p>
<ul>
<li>process.argv 是命令行参数数组,第一个元素是 node, 第二个元素是脚本文件名,从第三个元素开始每个元素是一个运行参数。<code>console.log(process.argv);</code></li>
<li>process.stdout 是标准输出流,通常我们使用的 console.log() 向标准输出打印字符,而 process.stdout.write() 函数提供了更底层的接口。</li>
<li>process.stdin 是标准输入流,初始时它是被暂停的,要想从标准输入读取数据,你必须恢复流,并手动编写流的事件响应函数。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.stdin.resume();</div><div class="line">	process.stdin.<span class="keyword">on</span>(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(data)</span> {</span></div><div class="line">	process.stdout.<span class="keyword">write</span>(<span class="string">'read from console: '</span> + data.toString());</div><div class="line">});</div></pre></td></tr></table></figure>

<ul>
<li>process.nextTick(callback) 的功能是为事件循环设置一项任务,Node.js 会在下次事件循环调响应时调用 callback 。<br>初学者很可能不理解这个函数的作用,有什么任务不能在当下执行完,需要交给下次事件循环响应来做呢?我们讨论过, Node.js 适合 I/O 密集型的应用,而不是计算密集型的应用,因为一个 Node.js 进程只有一个线程,因此在任何时刻都只有一个事件在执行。如果这个事件占用大量的 CPU 时间,执行事件循环中的下一个事件就需要等待很久,因此 Node.js 的一个编程原则就是尽量缩短每个事件的执行时间。 process.nextTick() 提供了一个这样的工具,可以把复杂的工作拆散,变成一个个较小的事件。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">(args, callback)</span> </span>{</div><div class="line">	somethingComplicated(args);</div><div class="line">	<span class="keyword">callback</span>();</div><div class="line">}</div><div class="line">doSomething(<span class="function"><span class="keyword">function</span> <span class="title">onEnd</span><span class="params">()</span> </span>{</div><div class="line">	compute();</div><div class="line">});</div></pre></td></tr></table></figure>

<p>我们假设 compute() 和 somethingComplicated() 是两个较为耗时的函数,以上的程序在调用 doSomething() 时会先执行 somethingComplicated() ,然后立即调用回调函数,在 onEnd() 中又会执行 compute() 。下面用 process.nextTick() 改写上面的程序:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">(args, callback)</span> </span>{</div><div class="line">	somethingComplicated(args);</div><div class="line">	process.nextTick(<span class="keyword">callback</span>);</div><div class="line">}</div><div class="line">doSomething(<span class="function"><span class="keyword">function</span> <span class="title">onEnd</span><span class="params">()</span> </span>{</div><div class="line">	compute();</div><div class="line">});</div></pre></td></tr></table></figure>

<p>改写后的程序会把上面耗时的操作拆分为两个事件,减少每个事件的执行时间,提高事件响应速度。不要使用 setTimeout(fn,0) 代替 process.nextTick(callback) ,前者比后者效率要低得多。我们探讨了 process 对象常用的几个成员,除此之外 process 还展示了 process.platform 、process.pid 、 process.execPath 、 process.memoryUsage() 等方法,以及 POSIX进程信号响应机制。有兴趣的读者可以访问 <a href="http://nodejs.org/api/process.html" target="_blank" rel="external">http://nodejs.org/api/process.html</a> 了解详细内容。</p>
<h3 id="console">console</h3>
<p>console 用于提供控制台标准输出,它是由 Internet Explorer 的 JScript 引擎提供的调试工具,后来逐渐成为浏览器的事实标准。Node.js 沿用了这个标准,提供与习惯行为一致的console 对象,用于向标准输出流( stdout )或标准错误流( stderr )输出字符。</p>
<ul>
<li>console.log() :向标准输出流打印字符并以换行符结束。 console.log 接受若干个参数,如果只有一个参数,则输出这个参数的字符串形式。如果有多个参数,则以类似于 C 语言 printf() 命令的格式输出。第一个参数是一个字符串,如果没有参数,只打印一个换行。</li>
<li>console.error() :与 console.log() 用法相同,只是向标准错误流输出。</li>
<li>console.trace() :向标准错误流输出当前的调用栈。</li>
</ul>
<h2 id="常用工具_util">常用工具 util</h2>
<p>util 是一个 Node.js 核心模块,提供常用函数的集合,用于弥补核心 JavaScript 的功能过于精简的不足。</p>
<h3 id="util-inherits">util.inherits</h3>
<p>util.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。JavaScript 的面向对象特性是基于原型的,与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性,而是通过原型复制来实现的,在这里我们只介绍 util.inherits 的用法,示例如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span><span class="params">()</span> </span>{</div><div class="line">	<span class="keyword">this</span>.name = <span class="string">'base'</span>;</div><div class="line">	<span class="keyword">this</span>.base = <span class="number">1991</span>;</div><div class="line">	<span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name);</div><div class="line">	};</div><div class="line">}</div><div class="line">Base.prototype.showName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">};</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span><span class="params">()</span> </span>{</div><div class="line">	<span class="keyword">this</span>.name = <span class="string">'sub'</span>;</div><div class="line">}</div><div class="line">util.inherits(Sub, Base);</div><div class="line"><span class="keyword">var</span> objBase = <span class="keyword">new</span> Base();</div><div class="line">objBase.showName();</div><div class="line">objBase.sayHello();</div><div class="line"><span class="built_in">console</span>.log(objBase);</div><div class="line"></div><div class="line"><span class="keyword">var</span> objSub = <span class="keyword">new</span> Sub();</div><div class="line">objSub.showName();</div><div class="line"><span class="comment">//objSub.sayHello();</span></div><div class="line"><span class="built_in">console</span>.log(objSub);</div></pre></td></tr></table></figure>

<p>我们定义了一个基础对象 Base 和一个继承自 Base 的 Sub , Base 有三个在构造函数内定义的属性和一个原型中定义的函数,通过 util.inherits 实现继承。<br>注意, Sub 仅仅继承了 Base 在原型中定义的函数,而构造函数内部创造的 base 属性和 sayHello 函数都没有被 Sub 继承。同时,在原型中定义的属性不会被 console.log 作为对象的属性输出。</p>
<h3 id="util-inspect">util.inspect</h3>
<p>util.inspect(object,[showHidden],[depth],[colors]) 是一个将任意对象转换为字符串的方法,通常用于调试和错误输出。它至少接受一个参数 object ,即要转换的对象。<br>showHidden 是一个可选参数,如果值为 true ,将会输出更多隐藏信息。<br>depth 表示最大递归的层数,如果对象很复杂,你可以指定层数以控制输出信息的多少。如果不指定 depth ,默认会递归2层,指定为 null 表示将不限递归层数完整遍历对象。<br>如果 color 值为 true ,输出格式将会以 ANSI 颜色编码,通常用于在终端显示更漂亮的效果。<br>特别要指出的是, util.inspect 并不会简单地直接把对象转换为字符串,即使该对象定义了 toString 方法也不会调用。</p>
<p>除了以上我们介绍的几个函数之外, util 还提供了 util.isArray() 、 util.isRegExp() 、util.isDate() 、 util.isError() 四个类型测试工具,以及 util.format() 、 util.debug()等工具。有兴趣的读者可以访问 <a href="http://nodejs.org/api/util.html" target="_blank" rel="external">http://nodejs.org/api/util.html</a> 了解详细内容。</p>
<h2 id="事件驱动_events">事件驱动 events</h2>
<p>events 是 Node.js 最重要的模块,没有“之一”,原因是 Node.js 本身架构就是事件式的,而它提供了唯一的接口,所以堪称 Node.js 事件编程的基石。 events 模块不仅用于用户代码与 Node.js 下层事件循环的交互,还几乎被所有的模块依赖。</p>
<h3 id="事件发射器">事件发射器</h3>
<p>events 模块只提供了一个对象: events.EventEmitter 。 EventEmitter 的核心就是事件发射与事件监听器功能的封装。 EventEmitter 的每个事件由一个事件名和若干个参数组成,事件名是一个字符串,通常表达一定的语义。对于每个事件, EventEmitter 支持若干个事件监听器。当事件发射时,注册到这个事件的事件监听器被依次调用,事件参数作为回调函数参数传递。<br>让我们以下面的例子解释这个过程:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter();</div><div class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span><span class="params">(arg1, arg2)</span> </span>{</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'listener1'</span>, arg1, arg2);</div><div class="line">});</div><div class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span><span class="params">(arg1, arg2)</span> </span>{</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'listener2'</span>, arg1, arg2);</div><div class="line">});</div><div class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'byvoid'</span>, <span class="number">1991</span>);</div></pre></td></tr></table></figure>

<p>运行的结果是:<br>listener1 byvoid 1991<br>listener2 byvoid 1991<br>运行结果中可以看到两个事件监听器回调函数被先后调用.<br>这就是 EventEmitter 最简单的用法。接下来我们介绍一下 EventEmitter 常用的API。</p>
<ul>
<li>EventEmitter.on(event, listener) 为指定事件注册一个监听器,接受一个字符串 event 和一个回调函数 listener 。</li>
<li>EventEmitter.emit(event, [arg1], [arg2], […]) 发射 event 事件,传递若干可选参数到事件监听器的参数表。</li>
<li>EventEmitter.once(event, listener) 为指定事件注册一个单次监听器,即监听器最多只会触发一次,触发后立刻解除该监听器。</li>
<li>EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器, listener 必须是该事件已经注册过的监听器。</li>
<li>EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器,如果指定 event ,则移除指定事件的所有监听器。<br>更详细的 API 文档参见 <a href="http://nodejs.org/api/events.html。" target="_blank" rel="external">http://nodejs.org/api/events.html。</a></li>
</ul>
<h3 id="error_事件">error 事件</h3>
<p>EventEmitter 定义了一个特殊的事件 error ,它包含了“错误”的语义,我们在遇到异常的时候通常会发射 error 事件。当 error 被发射时, EventEmitter 规定如果没有响应的监听器, Node.js 会把它当作异常,退出程序并打印调用栈。我们一般要为会发射 error事件的对象设置监听器,避免遇到错误后整个程序崩溃。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter();</div><div class="line">emitter.emit(<span class="string">'error'</span>);</div></pre></td></tr></table></figure>

<h3 id="继承_EventEmitter">继承 EventEmitter</h3>
<p>大多数时候我们不会直接使用 EventEmitter ,而是在对象中继承它。包括 fs 、 net 、http 在内的,只要是支持事件响应的核心模块都是 EventEmitter 的子类。<br>为什么要这样做呢?原因有两点。首先,具有某个实体功能的对象实现事件符合语义,事件的监听和发射应该是一个对象的方法。其次 JavaScript 的对象机制是基于原型的,支持部分多重继承,继承 EventEmitter 不会打乱对象原有的继承关系。</p>
<h2 id="文件系统_fs">文件系统 fs</h2>
<p>fs 模块是文件操作的封装,它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作。与其他模块不同的是, fs 模块中所有的操作都提供了异步的和同 步 的 两 个 版 本 , 例 如 读 取 文 件 内 容 的 函 数 有 异 步 的 fs.readFile() 和 同 步 的fs.readFileSync() 。我们以几个函数为代表,介绍 fs 常用的功能,并列出 fs 所有函数的定义和功能。</p>
<h3 id="fs-readFile">fs.readFile</h3>
<p>fs.readFile(filename,[encoding],[callback(err,data)]) 是最简单的读取文件的函数。它接受一个必选参数 filename ,表示要读取的文件名。第二个参数 encoding是可选的,表示文件的字符编码。 callback 是回调函数,用于接收文件的内容。如果不指定 encoding ,则 callback 就是第二个参数。回调函数提供两个参数 err 和 data , err 表示有没有错误发生, data 是文件内容。如果指定了 encoding , data 是一个解析后的字符串,否则 data 将会是以 Buffer 形式表示的二进制数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="comment">//fs.readFile('content.txt', 'utf-8', function(err, data) {</span></div><div class="line">fs.readFile(<span class="string">'content.txt'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, data)</span> </span>{</div><div class="line">	<span class="keyword">if</span> (err) {</div><div class="line">		<span class="built_in">console</span>.error(err);</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		<span class="built_in">console</span>.log(data);</div><div class="line">	}</div><div class="line">});</div></pre></td></tr></table></figure>

<p>Node.js 的异步编程接口习惯是以函数的最后一个参数为回调函数,通常一个函数只有一个回调函数。回调函数是实际参数中第一个是 err ,其余的参数是其他返回的内容。如果没有发生错误, err 的值会是 null 或undefined 。如果有错误发生, err 通常是 Error 对象的实例。</p>
<h3 id="fs-readFileSync">fs.readFileSync</h3>
<p>fs.readFileSync(filename, [encoding]) 是 fs.readFile 同步的版本。它接受的参数和 fs.readFile 相同,而读取到的文件内容会以函数返回值的形式返回。如果有错误发生, fs 将会抛出异常,你需要使用 try 和 catch 捕捉并处理异常。与同步 I/O 函数不同,Node.js 中异步函数大多没有返回值。</p>
<h3 id="fs-open">fs.open</h3>
<p>fs.open(path, flags, [mode], [callback(err, fd)]) 是 POSIX open 函数的封装,与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数, path 为文件的路径,flags 可以是以下值。</p>
<ul>
<li>r :以读取模式打开文件。</li>
<li>r+ :以读写模式打开文件。</li>
<li>w :以写入模式打开文件,如果文件不存在则创建。</li>
<li>w+ :以读写模式打开文件,如果文件不存在则创建。</li>
<li>a :以追加模式打开文件,如果文件不存在则创建。</li>
<li>a+ :以读取追加模式打开文件,如果文件不存在则创建</li>
</ul>
<p>mode 参数用于创建文件时给文件指定权限,默认是 0666。回调函数将会传递一个文件描述符fd 。</p>
<h3 id="fs-read">fs.read</h3>
<p>fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead,buffer)]) 是 POSIX read 函数的封装,相比 fs.readFile 提供了更底层的接口。 fs.read的功能是从指定的文件描述符 fd 中读取数据并写入 buffer 指向的缓冲区对象。 offset 是buffer 的写入偏移量。 length 是要从文件中读取的字节数。 position 是文件读取的起始位置,如果 position 的值为 null ,则会从当前文件指针的位置读取。回调函数传递bytesRead 和 buffer ,分别表示读取的字节数和缓冲区对象。<br>以下是一个使用 fs.open 和 fs.read 的示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.open(<span class="string">'content.txt'</span>, <span class="string">'r'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, fd)</span> </span>{</div><div class="line">	<span class="keyword">if</span> (err) {</div><div class="line">		<span class="built_in">console</span>.error(err);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">8</span>);</div><div class="line">	fs.read(fd, buf, <span class="number">0</span>, <span class="number">8</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, bytesRead, buffer)</span> </span>{</div><div class="line">	<span class="keyword">if</span> (err) {</div><div class="line">		<span class="built_in">console</span>.error(err);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	}</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'bytesRead: '</span> + bytesRead);</div><div class="line">		<span class="built_in">console</span>.log(buffer);</div><div class="line">	})</div><div class="line">});</div></pre></td></tr></table></figure>

<p>一般来说,除非必要,否则不要使用这种方式读取文件,因为它要求你手动管理缓冲区和文件指针,尤其是在你不知道文件大小的时候,这将会是一件很麻烦的事情。<br>列出了 fs 所有函数的定义和功能:</p>
<hr>
<table>
<thead>
<tr>
<th>功能</th>
<th style="text-align:center">异步函数</th>
<th style="text-align:right">同步函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开文件</td>
<td style="text-align:center">fs.open(path,flags, [mode], [callback(err,fd)])</td>
<td style="text-align:right">fs.openSync(path, flags, [mode])</td>
</tr>
<tr>
<td>关闭文件</td>
<td style="text-align:center">fs.close(fd, [callback(err)])</td>
<td style="text-align:right">fs.closeSync(fd)</td>
</tr>
<tr>
<td>读取文件(文件描述符)</td>
<td style="text-align:center">fs.read(fd,buffer,offset,length,position,[callback(err, bytesRead, buffer)])</td>
<td style="text-align:right">fs.readSync(fd, buffer, offset,length, position)</td>
</tr>
<tr>
<td>写入文件(文件描述符)</td>
<td style="text-align:center">fs.write(fd,buffer,offset,length,position,[callback(err, bytesWritten, buffer)])</td>
<td style="text-align:right">fs.writeSync(fd, buffer, offset,length, position)</td>
</tr>
<tr>
<td>读取文件内容</td>
<td style="text-align:center">fs.readFile(filename,[encoding],[callback(err, data)])</td>
<td style="text-align:right">fs.readFileSync(filename,[encoding])</td>
</tr>
<tr>
<td>写入文件内容</td>
<td style="text-align:center">fs.writeFile(filename,data,[encoding],[callback(err)])</td>
<td style="text-align:right">fs.writeFileSync(filename, data,[encoding])</td>
</tr>
<tr>
<td>删除文件</td>
<td style="text-align:center">fs.unlink(path, [callback(err)])</td>
<td style="text-align:right">fs.unlinkSync(path)</td>
</tr>
<tr>
<td>创建目录</td>
<td style="text-align:center">fs.mkdir(path, [mode], [callback(err)])</td>
<td style="text-align:right">fs.mkdirSync(path, [mode])</td>
</tr>
<tr>
<td>删除目录</td>
<td style="text-align:center">fs.rmdir(path, [callback(err)])</td>
<td style="text-align:right">fs.rmdirSync(path)</td>
</tr>
<tr>
<td>读取目录</td>
<td style="text-align:center">fs.readdir(path, [callback(err, files)])</td>
<td style="text-align:right">fs.readdirSync(path)</td>
</tr>
<tr>
<td>获取真实路径</td>
<td style="text-align:center">fs.realpath(path, [callback(err,resolvedPath)])</td>
<td style="text-align:right">fs.realpathSync(path)</td>
</tr>
<tr>
<td>更名</td>
<td style="text-align:center">fs.rename(path1, path2, [callback(err)])</td>
<td style="text-align:right">fs.renameSync(path1, path2)</td>
</tr>
<tr>
<td>截断</td>
<td style="text-align:center">fs.truncate(fd, len, [callback(err)])</td>
<td style="text-align:right">fs.truncateSync(fd, len)</td>
</tr>
<tr>
<td>更改所有权</td>
<td style="text-align:center">fs.chown(path, uid, gid, [callback(err)])</td>
<td style="text-align:right">fs.chownSync(path, uid, gid)</td>
</tr>
<tr>
<td>更改所有权(文件描述符)</td>
<td style="text-align:center">fs.fchown(fd, uid, gid, [callback(err)])</td>
<td style="text-align:right">fs.fchownSync(fd, uid, gid)</td>
</tr>
<tr>
<td>更改所有权(不解析符号链接)</td>
<td style="text-align:center">fs.lchown(path, uid, gid, [callback(err)])</td>
<td style="text-align:right">fs.lchownSync(path, uid, gid)</td>
</tr>
<tr>
<td>更改权限</td>
<td style="text-align:center">fs.chmod(path, mode, [callback(err)])</td>
<td style="text-align:right">fs.chmodSync(path, mode)</td>
</tr>
<tr>
<td>更改权限(文件描述符)</td>
<td style="text-align:center">fs.fchmod(fd, mode, [callback(err)])</td>
<td style="text-align:right">fs.fchmodSync(fd, mode)</td>
</tr>
<tr>
<td>更改权限(不解析符号链接)</td>
<td style="text-align:center">fs.lchmod(path, mode, [callback(err)])</td>
<td style="text-align:right">fs.lchmodSync(path, mode)</td>
</tr>
<tr>
<td>获取文件信息</td>
<td style="text-align:center">fs.stat(path, [callback(err, stats)])</td>
<td style="text-align:right">fs.statSync(path)</td>
</tr>
<tr>
<td>获取文件信息(文件描述符)</td>
<td style="text-align:center">fs.fstat(fd, [callback(err, stats)])</td>
<td style="text-align:right">fs.fstatSync(fd)</td>
</tr>
<tr>
<td>获取文件信息(不解析符号链接)</td>
<td style="text-align:center">fs.lstat(path, [callback(err, stats)])</td>
<td style="text-align:right">fs.lstatSync(path)</td>
</tr>
<tr>
<td>创建硬链接</td>
<td style="text-align:center">fs.link(srcpath, dstpath, [callback(err)])</td>
<td style="text-align:right">fs.linkSync(srcpath, dstpath)</td>
</tr>
<tr>
<td>创建符号链接</td>
<td style="text-align:center">fs.symlink(linkdata, path, [type],[callback(err)])</td>
<td style="text-align:right">fs.symlinkSync(linkdata, path,[type])</td>
</tr>
<tr>
<td>读取链接</td>
<td style="text-align:center">fs.readlink(path, [callback(err,linkString)])</td>
<td style="text-align:right">fs.readlinkSync(path)</td>
</tr>
<tr>
<td>修改文件时间戳</td>
<td style="text-align:center">fs.utimes(path, atime, mtime, [callback(err)])</td>
<td style="text-align:right">fs.utimesSync(path, atime, mtime)</td>
</tr>
<tr>
<td>修改 文件时间戳(文件描述符)</td>
<td style="text-align:center">fs.futimes(fd, atime, mtime, [callback(err)])</td>
<td style="text-align:right">fs.futimesSync(fd, atime, mtime)</td>
</tr>
<tr>
<td>同步磁盘缓存</td>
<td style="text-align:center">fs.fsync(fd, [callback(err)])</td>
<td style="text-align:right">fs.fsyncSync(fd)</td>
</tr>
</tbody>
</table>
<h2 id="HTTP_服务器与客户端">HTTP 服务器与客户端</h2>
<p>Node.js 标准库提供了 http 模块,其中封装了一个高效的 HTTP 服务器和一个简易的HTTP 客户端。 http.Server 是一个基于事件的 HTTP 服务器,它的核心由 Node.js 下层 C++部分实现,而接口由 JavaScript 封装,兼顾了高性能与简易性。 http.request 则是一个HTTP 客户端工具,用于向 HTTP 服务器发起请求,例如实现 Pingback 1 或者内容抓取。</p>
<h3 id="HTTP_服务器">HTTP 服务器</h3>
<p>http.Server 是 http 模块中的 HTTP 服务器对象,用 Node.js 做的所有基于 HTTP 协议的系统,如网站、社交应用甚至代理服务器,都是基于 http.Server 实现的。它提供了一套封装级别很低的 API,仅仅是流控制和简单的消息解析,所有的高层功能都要通过它的接口来实现。</p>
<h4 id="http-Server_的事件">http.Server 的事件</h4>
<p>http.Server 是一个基于事件的 HTTP 服务器,所有的请求都被封装为独立的事件,开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自EventEmitter ,提供了以下几个事件。</p>
<ul>
<li>request :当客户端请求到来时,该事件被触发,提供两个参数 req 和 res ,分别是http.ServerRequest 和 http.ServerResponse 的实例,表示请求和响应信息。</li>
<li>connection :当 TCP 连接建立时,该事件被触发,提供一个参数 socket ,为net.Socket 的实例。 connection 事件的粒度要大于 request ,因为客户端在Keep-Alive 模式下可能会在同一个连接内发送多次请求。</li>
<li>close :当服务器关闭时,该事件被触发。注意不是在用户连接断开时。<br>除此之外还有 checkContinue 、 upgrade 、 clientError 事件,通常我们不需要关心,只有在实现复杂的 HTTP 服务器的时候才会用到。<br>在 这 些 事 件 中 , 最 常 用 的 就 是 request 了 , 因 此 http 提 供 了 一 个 捷 径 :http.createServer([requestListener]) , 功 能 是 创 建 一 个 HTTP 服 务 器 并 将requestListener 作为 request 事件的监听函数,这也是我们前面例子中使用的方法。事实上它显式的实现方法是:</li>
</ul>
<figure class="highlight node"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> http.Server();</div><div class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{</div><div class="line">	res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>});</div><div class="line">	res.write(<span class="string">'&lt;h1&gt;Node.js&lt;/h1&gt;'</span>);</div><div class="line">	res.end(<span class="string">'&lt;p&gt;Hello World&lt;/p&gt;'</span>);</div><div class="line">});</div><div class="line">server.listen(<span class="number">3000</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"HTTP server is listening at port 3000."</span>);</div></pre></td></tr></table></figure>

<h4 id="http-ServerRequest">http.ServerRequest</h4>
<p>http.ServerRequest 是 HTTP 请求的信息,是后端开发者最关注的内容。它一般由http.Server 的 request 事件发送,作为第一个参数传递,通常简称 request 或 req 。ServerRequest 提供一些属性,表 4-2 中列出了这些属性。<br>HTTP 请求一般可以分为两部分:请求头(Request Header)和请求体(Requset Body)。以上内容由于长度较短都可以在请求头解析完成后立即读取。而请求体可能相对较长,需要一定的时间传输,因此 http.ServerRequest 提供了以下3个事件用于控制请求体传输。</p>
<ul>
<li>data :当请求体数据到来时,该事件被触发。该事件提供一个参数 chunk ,表示接收到的数据。如果该事件没有被监听,那么请求体将会被抛弃。该事件可能会被调用多次。</li>
<li>end :当请求体数据传输完成时,该事件被触发,此后将不会再有数据到来。</li>
<li>close : 用户当前请求结束时,该事件被触发。不同于 end ,如果用户强制终止了传输,也还是调用 close 。</li>
</ul>
<p>ServerRequest 的属性</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>complete</td>
<td style="text-align:center">客户端请求是否已经发送完成</td>
</tr>
<tr>
<td>httpVersion</td>
<td style="text-align:center">HTTP 协议版本,通常是 1.0 或 1.1</td>
</tr>
<tr>
<td>method</td>
<td style="text-align:center">HTTP 请求方法,如 GET、POST、PUT、DELETE 等</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">原始的请求路径,例如 /static/image/x.jpg 或 /user?name=byvoid</td>
</tr>
<tr>
<td>headers</td>
<td style="text-align:center">HTTP 请求头</td>
</tr>
<tr>
<td>trailers</td>
<td style="text-align:center">HTTP 请求尾(不常见)</td>
</tr>
<tr>
<td>connection</td>
<td style="text-align:center">当前 HTTP 连接套接字,为 net.Socket 的实例</td>
</tr>
<tr>
<td>socket</td>
<td style="text-align:center">connection 属性的别名</td>
</tr>
<tr>
<td>client</td>
<td style="text-align:center">client 属性的别名</td>
</tr>
</tbody>
</table>
<h4 id="获取_GET_请求内容">获取 GET 请求内容</h4>
<p>注意, http.ServerRequest 提供的属性中没有类似于 PHP 语言中的 $_GET 或$_POST 的属性,那我们如何接受客户端的表单请求呢?由于 GET 请求直接被嵌入在路径中, URL是完整的请求路径,包括了 ? 后面的部分,因此你可以手动解析后面的内容作为 GET请求的参数。Node.js 的 url 模块中的 parse 函数提供了这个功能,例如:</p>
<figure class="highlight node"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{</div><div class="line">	res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});</div><div class="line">	res.end(util.inspect(url.parse(req.url, <span class="literal">true</span>)));</div><div class="line">}).listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>

<p>在浏览器中访问 <a href="http://127.0.0.1:3000/user?name=byvoid&amp;email=byvoid@byvoid.com" target="_blank" rel="external">http://127.0.0.1:3000/user?name=byvoid&amp;email=byvoid@byvoid.com</a>, 我们可以看到浏览器返回的结果.<br>通过 url.parse ,原始的 path 被解析为一个对象,其中 query 就是我们所谓的 GET请求的内容,而路径则是 pathname 。</p>
<h4 id="获取_POST_请求内容">获取 POST 请求内容</h4>
<p>HTTP 协议 1.1 版本提供了8种标准的请求方法,其中最常见的就是 GET 和 POST。相比GET 请 求 把 所 有 的 内 容 编 码 到 访 问 路 径 中 , POST 请 求 的 内 容 全 部 都 在 请 求 体 中 。http.ServerRequest 并没有一个属性内容为请求体,原因是等待请求体传输可能是一件耗时的工作,譬如上传文件。而很多时候我们可能并不需要理会请求体的内容,恶意的 POST请求会大大消耗服务器的资源。所以 Node.js 默认是不会解析请求体的,当你需要的时候,需要手动来做。让我们看看实现方法:</p>
<figure class="highlight node"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</div><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{</div><div class="line">	<span class="keyword">var</span> post = <span class="string">''</span>;</div><div class="line">	req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> </span>{</div><div class="line">		post += chunk;</div><div class="line">	});</div><div class="line">	req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">		post = querystring.parse(post);</div><div class="line">		res.end(util.inspect(post));</div><div class="line">	});</div><div class="line">}).listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>

<p>上面代码并没有在请求响应函数中向客户端返回信息,而是定义了一个 post 变量,用于在闭包中暂存请求体的信息。通过 req 的 data 事件监听函数,每当接受到请求体的数据,就累加到 post 变量中。在 end 事件触发后,通过 querystring.parse 将 post 解析为真正的 POST 请求格式,然后向客户端返回。<br>不要在真正的生产应用中使用上面这种简单的方法来获取 POST 请求,因为它有严重的效率问题和安全问题,这只是一个帮助你理解的示例。</p>
<h4 id="http-ServerResponse">http.ServerResponse</h4>
<p>http.ServerResponse 是返回给客户端的信息,决定了用户最终能看到的结果。它也是由 http.Server 的 request 事件发送的,作为第二个参数传递,一般简称为response 或 res 。http.ServerResponse 有三个重要的成员函数,用于返回响应头、响应内容以及结束请求。</p>
<ul>
<li>response.writeHead(statusCode, [headers]) :向请求的客户端发送响应头。statusCode 是 HTTP 状态码,如 200 (请求成功)、404 (未找到)等。 headers是一个类似关联数组的对象,表示响应头的每个属性。该函数在一个请求内最多只能调用一次,如果不调用,则会自动生成一个响应头。</li>
<li>response.write(data, [encoding]) :向请求的客户端发送响应内容。 data 是一个 Buffer 或字符串,表示要发送的内容。如果 data 是字符串,那么需要指定encoding 来说明它的编码方式,默认是 utf-8 。在 response.end 调用之前,response.write 可以被多次调用。</li>
<li>response.end([data], [encoding]) :结束响应,告知客户端所有发送已经完成。当所有要返回的内容发送完毕的时候,该函数 必须 被调用一次。它接受两个可选参数,意义和 response.write 相同。如果不调用该函数,客户端将永远处于等待状态。</li>
</ul>
<h3 id="HTTP_客户端">HTTP 客户端</h3>
<p>http 模块提供了两个函数 http.request 和 http.get ,功能是作为客户端向 HTTP服务器发起请求。</p>
<ul>
<li>http.request(options, callback) 发起 HTTP 请求。接受两个参数, option 是一个类似关联数组的对象,表示请求的参数, callback 是请求的回调函数。 option常用的参数如下所示。<ul>
<li>host :请求网站的域名或 IP 地址。</li>
<li>port :请求网站的端口,默认 80。</li>
<li>method :请求方法,默认是 GET。</li>
<li>path :请求的相对于根的路径,默认是“ / ”。 QueryString 应该包含在其中。例如 /search?query=byvoid 。</li>
<li>headers :一个关联数组对象,为请求头的内容。<br>callback 传递一个参数,为 http.ClientResponse 的实例。http.request 返回一个 http.ClientRequest 的实例。下面是一个通过 http.request 发送 POST 请求的代码:</li>
</ul>
</li>
</ul>
<figure class="highlight node"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</div><div class="line"><span class="keyword">var</span> contents = querystring.stringify({</div><div class="line">	name: <span class="string">'byvoid'</span>,</div><div class="line">	email: <span class="string">'byvoid@byvoid.com'</span>,</div><div class="line">	address: <span class="string">'Zijing 2#, Tsinghua University'</span>,</div><div class="line">});</div><div class="line"><span class="keyword">var</span> options = {</div><div class="line">	host: <span class="string">'www.byvoid.com'</span>,</div><div class="line">	path: <span class="string">'/application/node/post.php'</span>,</div><div class="line">	method: <span class="string">'POST'</span>,</div><div class="line">	headers: {</div><div class="line">		<span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</div><div class="line">		<span class="string">'Content-Length'</span> : contents.length</div><div class="line">	}</div><div class="line">};</div><div class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span><span class="params">(res)</span> </span>{</div><div class="line">	res.setEncoding(<span class="string">'utf8'</span>);</div><div class="line">	res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>{</div><div class="line">		<span class="built_in">console</span>.log(data);</div><div class="line">	});</div><div class="line">});</div><div class="line">req.write(contents);</div><div class="line">req.end();</div></pre></td></tr></table></figure>

<ul>
<li>http.get(options, callback) http 模块还提供了一个更加简便的方法用于处理GET请求: http.get 。它是 http.request 的简化版,唯一的区别在于 http.get自动将请求方法设为了 GET 请求,同时不需要手动调用 req.end() 。</li>
</ul>
<figure class="highlight node"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line">http.get({host: <span class="string">'www.byvoid.com'</span>}, <span class="function"><span class="keyword">function</span><span class="params">(res)</span> </span>{</div><div class="line">	res.setEncoding(<span class="string">'utf8'</span>);</div><div class="line">	res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>{</div><div class="line">		<span class="built_in">console</span>.log(data);</div><div class="line">	});</div><div class="line">});</div></pre></td></tr></table></figure>

<h4 id="http-ClientRequest">http.ClientRequest</h4>
<p>http.ClientRequest 是由 http.request 或 http.get 返回产生的对象,表示一个已经产生而且正在进行中的 HTTP 请求。它提供一个 response 事件,即 http.request或 http.get 第二个参数指定的回调函数的绑定对象。我们也可以显式地绑定这个事件的监听函数:</p>
<figure class="highlight node"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> req = http.get({host: <span class="string">'www.byvoid.com'</span>});</div><div class="line">req.on(<span class="string">'response'</span>, <span class="function"><span class="keyword">function</span><span class="params">(res)</span> </span>{</div><div class="line">	res.setEncoding(<span class="string">'utf8'</span>);</div><div class="line">	res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>{</div><div class="line">		<span class="built_in">console</span>.log(data);</div><div class="line">	});</div><div class="line">});</div></pre></td></tr></table></figure>

<p>http.ClientRequest 像 http.ServerResponse 一样也提供了 write 和 end 函数,用于向服务器发送请求体,通常用于 POST、 PUT 等操作。所有写结束以后必须调用 end函数以通知服务器,否则请求无效。 http.ClientRequest 还提供了以下函数。</p>
<ul>
<li>request.abort() :终止正在发送的请求。</li>
<li>request.setTimeout(timeout, [callback]) :设置请求超时时间, timeout 为毫秒数。当请求超时以后, callback 将会被调用。<br>此外还有 request.setNoDelay([noDelay]) 、 request.setSocketKeepAlive([enable] , [initialDelay]) 等函数,具体内容请参见 Node.js 文档。</li>
</ul>
<h4 id="http-ClientResponse">http.ClientResponse</h4>
<p>http.ClientResponse 与 http.ServerRequest 相似,提供了三个事件 data 、 end和 close ,分别在数据到达、传输结束和连接结束时触发,其中 data 事件传递一个参数chunk ,表示接收到的数据。<br>http.ClientResponse 也提供了一些属性,用于表示请求的结果状态:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>statusCode</td>
<td style="text-align:center">HTTP 状态码,如 200、404、500</td>
</tr>
<tr>
<td>httpVersion</td>
<td style="text-align:center">HTTP 协议版本,通常是 1.0 或 1.1</td>
</tr>
<tr>
<td>headers</td>
<td style="text-align:center">HTTP 请求头</td>
</tr>
<tr>
<td>trailers</td>
<td style="text-align:center">HTTP 请求尾(不常见)</td>
</tr>
</tbody>
</table>
<p>http.ClientResponse 还提供了以下几个特殊的函数。</p>
<ul>
<li>response.setEncoding([encoding]) :设置默认的编码,当 data 事件被触发时,数据将会以 encoding 编码。默认值是 null ,即不编码,以 Buffer 的形式存储。常用编码为 utf8。</li>
<li>response.pause() :暂停接收数据和发送事件,方便实现下载功能。</li>
<li>response.resume() :从暂停的状态中恢复。</li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/NodeJs/">NodeJs</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/NodeJs/">NodeJs</a>
</div>



<div class="article-share" id="share">

  
<div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a class="jiathis_button_twitter">Twitter</a>
    <a class="jiathis_button_evernote">EverNote</a>
    <a href="http://www.jiathis.com/share?uid=1501277" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
</div>
<script type="text/javascript" >
    var jiathis_config={
    data_track_clickback:true,
    sm:"copy,renren,cqq",
    pic:"",
    summary:"",
    
  </script> 
<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=
" charset="utf-8"></script>      


</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/10/11/有用的技术站点/" title="有用的技术站点">
  <strong>PREVIOUS:</strong><br/>
  <span>
  有用的技术站点</span>
</a>
</div>


<div class="next">
<a href="/2014/10/10/Ubuntu快捷键/"  title="Ubuntu快捷键 ">
 <strong>NEXT:</strong><br/> 
 <span>Ubuntu快捷键 
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#全局对象"><span class="toc-number">1.</span> <span class="toc-text">全局对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局对象与全局变量"><span class="toc-number">1.1.</span> <span class="toc-text">全局对象与全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#process"><span class="toc-number">1.2.</span> <span class="toc-text">process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#console"><span class="toc-number">1.3.</span> <span class="toc-text">console</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用工具_util"><span class="toc-number">2.</span> <span class="toc-text">常用工具 util</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#util-inherits"><span class="toc-number">2.1.</span> <span class="toc-text">util.inherits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#util-inspect"><span class="toc-number">2.2.</span> <span class="toc-text">util.inspect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件驱动_events"><span class="toc-number">3.</span> <span class="toc-text">事件驱动 events</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件发射器"><span class="toc-number">3.1.</span> <span class="toc-text">事件发射器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error_事件"><span class="toc-number">3.2.</span> <span class="toc-text">error 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承_EventEmitter"><span class="toc-number">3.3.</span> <span class="toc-text">继承 EventEmitter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统_fs"><span class="toc-number">4.</span> <span class="toc-text">文件系统 fs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fs-readFile"><span class="toc-number">4.1.</span> <span class="toc-text">fs.readFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs-readFileSync"><span class="toc-number">4.2.</span> <span class="toc-text">fs.readFileSync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs-open"><span class="toc-number">4.3.</span> <span class="toc-text">fs.open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs-read"><span class="toc-number">4.4.</span> <span class="toc-text">fs.read</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP_服务器与客户端"><span class="toc-number">5.</span> <span class="toc-text">HTTP 服务器与客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP_服务器"><span class="toc-number">5.1.</span> <span class="toc-text">HTTP 服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http-Server_的事件"><span class="toc-number">5.1.1.</span> <span class="toc-text">http.Server 的事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http-ServerRequest"><span class="toc-number">5.1.2.</span> <span class="toc-text">http.ServerRequest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取_GET_请求内容"><span class="toc-number">5.1.3.</span> <span class="toc-text">获取 GET 请求内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取_POST_请求内容"><span class="toc-number">5.1.4.</span> <span class="toc-text">获取 POST 请求内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http-ServerResponse"><span class="toc-number">5.1.5.</span> <span class="toc-text">http.ServerResponse</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP_客户端"><span class="toc-number">5.2.</span> <span class="toc-text">HTTP 客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http-ClientRequest"><span class="toc-number">5.2.1.</span> <span class="toc-text">http.ClientRequest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#http-ClientResponse"><span class="toc-number">5.2.2.</span> <span class="toc-text">http.ClientResponse</span></a></li></ol></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">Archives</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">8</span></li></ul>
  </div>


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
			<li><a href="/categories/NodeJs/" title="NodeJs">NodeJs<sup>4</sup></a></li>
		
			<li><a href="/categories/git-submodule/" title="git submodule">git submodule<sup>1</sup></a></li>
		
			<li><a href="/categories/ubuntu快捷键/" title="ubuntu快捷键">ubuntu快捷键<sup>1</sup></a></li>
		
			<li><a href="/categories/useful-website/" title="useful_website">useful_website<sup>1</sup></a></li>
		
			<li><a href="/categories/zhong/" title="zhong">zhong<sup>0</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/NodeJs/" title="NodeJs">NodeJs<sup>4</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/ss/" title="ss">ss<sup>0</sup></a></li>
		
			<li><a href="/tags/ubuntu/" title="ubuntu">ubuntu<sup>1</sup></a></li>
		
			<li><a href="/tags/useful/" title="useful">useful<sup>1</sup></a></li>
		
		</ul>
</div>


  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/NodeJs/" style="font-size: 20.00px;">NodeJs</a><a href="/tags/git/" style="font-size: 15.00px;">git</a><a href="/tags/ss/" style="font-size: 10.00px;">ss</a><a href="/tags/ubuntu/" style="font-size: 15.00px;">ubuntu</a><a href="/tags/useful/" style="font-size: 15.00px;">useful</a>
    </div>
  </div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
      <li><a href="http://yuexiahandao.github.com" target="_blank" title="Gavin Zhang">Gavin's Blog</a></li>
      <li><a href="http://hexo.io" target="_blank" title="Hexo">Hexo</a></li>
    </ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Welcome to Gavin Zhang&#39;s personal blog! <br/>
			Welcome visiting</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/u/2113616192" target="_blank" title="weibo"></a>
		
		
		<a href="https://twitter.com/yuexiahandao" target="_blank" title="twitter"></a>
		
		
		<a href="https://github.com/yuexiahandao" target="_blank" title="github"></a>
		
		
		<a href="https://www.facebook.com/gavinzhang" target="_blank" title="facebook"></a>
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2014 
		
		<a href="http://yuexiahandao.github.com" target="_blank" title="Gavin Zhang">Gavin Zhang</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"null"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 




<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'null', 'null');  
ga('send', 'pageview');
</script>


  </body>
</html>
